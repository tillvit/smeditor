import{a1 as c,ax as l,ay as _,a3 as d,ak as p,T as o,f as h,al as m}from"./Simfile-DgZSKnU-.js";const s=new p;class a extends c{constructor(t,e=100,i=100){super(t),this.tileTransform=new l,this._width=e,this._height=i,this.uvMatrix=this.texture.uvMatrix||new _(t),this.pluginName="tilingSprite",this.uvRespectAnchor=!1}get clampMargin(){return this.uvMatrix.clampMargin}set clampMargin(t){this.uvMatrix.clampMargin=t,this.uvMatrix.update(!0)}get tileScale(){return this.tileTransform.scale}set tileScale(t){this.tileTransform.scale.copyFrom(t)}get tilePosition(){return this.tileTransform.position}set tilePosition(t){this.tileTransform.position.copyFrom(t)}_onTextureUpdate(){this.uvMatrix&&(this.uvMatrix.texture=this._texture),this._cachedTint=16777215}_render(t){const e=this._texture;!e||!e.valid||(this.tileTransform.updateLocalTransform(),this.uvMatrix.update(),t.batch.setObjectRenderer(t.plugins[this.pluginName]),t.plugins[this.pluginName].render(this))}_calculateBounds(){const t=this._width*-this._anchor._x,e=this._height*-this._anchor._y,i=this._width*(1-this._anchor._x),r=this._height*(1-this._anchor._y);this._bounds.addFrame(this.transform,t,e,i,r)}getLocalBounds(t){return this.children.length===0?(this._bounds.minX=this._width*-this._anchor._x,this._bounds.minY=this._height*-this._anchor._y,this._bounds.maxX=this._width*(1-this._anchor._x),this._bounds.maxY=this._height*(1-this._anchor._y),t||(this._localBoundsRect||(this._localBoundsRect=new d),t=this._localBoundsRect),this._bounds.getRectangle(t)):super.getLocalBounds.call(this,t)}containsPoint(t){this.worldTransform.applyInverse(t,s);const e=this._width,i=this._height,r=-e*this.anchor._x;if(s.x>=r&&s.x<r+e){const n=-i*this.anchor._y;if(s.y>=n&&s.y<n+i)return!0}return!1}destroy(t){super.destroy(t),this.tileTransform=null,this.uvMatrix=null}static from(t,e){const i=t instanceof o?t:o.from(t,e);return new a(i,e.width,e.height)}get width(){return this._width}set width(t){this._width=t}get height(){return this._height}set height(t){this._height=t}}class x extends a{constructor(t,e=64){super(t),this.tileScale.set(e/this.texture.width),this.texture.on("update",()=>{this.tileScale.set(e/this.texture.width)}),this.uvRespectAnchor=!0,this.anchor.y=1,this.x=-e/2,this.width=e}}class T extends x{_playing=!1;_autoUpdate=!1;_isConnectedToTicker=!1;_tickerUpdate=this.update.bind(this);_currentTime=0;_textures;_previousFrame=null;onComplete=null;onLoop=null;onFrameChange=null;animationSpeed=1;loop=!1;updateAnchor=!1;constructor(t,e){super(t[0],e),this.textures=t}stop(){this._playing&&(this._playing=!1,this._autoUpdate&&this._isConnectedToTicker&&(h.shared.remove(this._tickerUpdate),this._isConnectedToTicker=!1))}play(){this._playing||(this._playing=!0,this._autoUpdate&&!this._isConnectedToTicker&&(h.shared.add(this._tickerUpdate,this,m.HIGH),this._isConnectedToTicker=!0))}gotoAndStop(t){this.stop(),this.currentFrame=t}gotoAndPlay(t){this.currentFrame=t,this.play()}update(t){if(!this._playing)return;const e=this.animationSpeed*t,i=this.currentFrame;this._currentTime+=e,this._currentTime<0&&!this.loop?(this.gotoAndStop(0),this.onComplete?.()):this._currentTime>=this._textures.length&&!this.loop?(this.gotoAndStop(this._textures.length-1),this.onComplete?.()):i!==this.currentFrame&&(this.loop&&this.onLoop&&(this.animationSpeed>0&&this.currentFrame<i||this.animationSpeed<0&&this.currentFrame>i)&&this.onLoop(),this.updateTexture())}updateTexture(){const t=this.currentFrame;this._previousFrame!==t&&(this._previousFrame=t,this.texture=this._textures[t],this._textureID=-1,this._textureTrimmedID=-1,this._cachedTint=16777215,this.uvs=this._texture._uvs.uvsFloat32,this.updateAnchor&&this._anchor.copyFrom(this._texture.defaultAnchor),this.onFrameChange?.(this.currentFrame))}destroy(t){this.stop(),super.destroy(t),this.onComplete=null,this.onFrameChange=null,this.onLoop=null}get totalFrames(){return this._textures?.length??0}get textures(){return this._textures??[]}set textures(t){this._textures=t,this._previousFrame=null,this.gotoAndStop(0),this.updateTexture()}get currentFrame(){let t=Math.floor(this._currentTime)%this._textures.length;return t<0&&(t+=this._textures.length),t}set currentFrame(t){if(t<0||t>this.totalFrames-1)throw new Error(`[AnimatedSprite]: Invalid frame index value ${t}, expected to be between 0 and totalFrames ${this.totalFrames}.`);const e=this.currentFrame;this._currentTime=t,e!==this.currentFrame&&this.updateTexture()}get playing(){return this._playing}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,!this._autoUpdate&&this._isConnectedToTicker?(h.shared.remove(this._tickerUpdate),this._isConnectedToTicker=!1):this._autoUpdate&&!this._isConnectedToTicker&&this._playing&&(h.shared.add(this._tickerUpdate),this._isConnectedToTicker=!0))}}export{T as A,x as H,a as T};
