(function(){"use strict";const A=["Hold","Roll"];function F(u){return A.includes(u.type)}navigator.userAgent.indexOf("Mac OS X")>-1;function k(u,t,s){if(s=s??(i=>i),u.length==0)return-1;if(t>=s(u[u.length-1])){let i=u.length-1;for(;i>0&&s(u[i-1])==t;)i--;return i}let o=0,e=u.length;for(;o<=e&&o<u.length;){let i=o+e>>>1;if(s(u[i])==t){for(;i>0&&s(u[i-1])==t;)i--;return i}s(u[i])<t&&(o=i+1),s(u[i])>t&&(e=i-1)}return Math.max(0,e)}function M(u,t,s,o){if(u.length==0)return[0,0];let e=k(u,t,o);for(o(u[e])<t&&e++;u[e-1]&&o(u[e-1])==t;)e--;let i=k(u,s,o);for(o(u[i])>s&&i--;u[i+1]&&o(u[i+1])==s;)i++;return[e,i+1]}var n=(u=>(u[u.NONE=0]="NONE",u[u.LEFT_HEEL=1]="LEFT_HEEL",u[u.LEFT_TOE=2]="LEFT_TOE",u[u.RIGHT_HEEL=3]="RIGHT_HEEL",u[u.RIGHT_TOE=4]="RIGHT_TOE",u))(n||{});const H=[1,2,3,4],v=[0,2,1,4,3],x={DOUBLESTEP:850,BRACKETJACK:20,JACK:40,JUMP:0,SLOW_BRACKET:300,TWISTED_FOOT:1e5,BRACKETTAP:400,XO_BR:200,HOLDSWITCH:55,MINE:1e4,FOOTSWITCH:325,MISSED_FOOTSWITCH:500,FACING:3,DISTANCE:6,SPIN:1e3,SIDESWITCH:130,CROWDED_BRACKET:0,OTHER:0};class P{action=[];combinedColumns=[];movedFeet=new Set;holdFeet=new Set;second;beat;rowKey;footColumns=[];constructor(t,s,o=[]){this.second=t.second,this.beat=t.beat,this.rowKey=t.id,this.action=[...s],this.footColumns=[...o]}get leftHeel(){return this.footColumns[1]}get leftToe(){return this.footColumns[2]}get rightHeel(){return this.footColumns[3]}get rightToe(){return this.footColumns[4]}toKey(){let t="";for(let e=0;e<H.length;e++)this.movedFeet.has(H[e])&&(t+=H[e]);let s="";for(let e=0;e<H.length;e++)this.holdFeet.has(H[e])&&(s+=H[e]);let o="";for(let e=1;e<this.footColumns.length;e++)this.footColumns[e]!==-1?o+=this.footColumns[e]:o+=".";return`${this.rowKey}-${this.action.join("")}-${this.combinedColumns.join("")}-${t}-${s}-${o}`}}class N{name;layout;columnCount;upArrows;downArrows;sideArrows;constructor(t,s,o,e,i){this.name=t,this.layout=s,this.columnCount=s.length,this.upArrows=o,this.downArrows=e,this.sideArrows=i}getFacingDirectionCosine(t,s){if(t==s)return 0;let o=this.layout[s].x-this.layout[t].x;const e=this.layout[s].y-this.layout[t].y,i=Math.sqrt(o*o+e*e);return o/=i,o}getYDifference(t,s){if(t==s)return 0;const o=this.layout[s].x-this.layout[t].x;let e=this.layout[s].y-this.layout[t].y;const i=Math.sqrt(o*o+e*e);e/=i;const l=e<=0;return e=Math.pow(e,4),l&&(e=-e),e}averagePoint(t,s){return t==-1&&s==-1?{x:0,y:0}:t==-1?this.layout[s]:s==-1?this.layout[t]:{x:(this.layout[t].x+this.layout[s].x)/2,y:(this.layout[t].y+this.layout[s].y)/2}}getDistanceSq(t,s){const o=this.layout[t],e=this.layout[s];return(o.y-e.y)*(o.y-e.y)+(o.x-e.x)*(o.x-e.x)}getDistanceSqPoints(t,s){return(t.y-s.y)*(t.y-s.y)+(t.x-s.x)*(t.x-s.x)}bracketCheck(t,s){return this.getDistanceSq(t,s)<=2}getPlayerAngle(t,s){const o=this.layout[t],e=this.layout[s],i=e.x-o.x,l=e.y-o.y,r=1,a=0,c=i*r+l*a,d=i*a-l*r;return Math.atan2(d,c)}}const G={"dance-single":new N("dance-single",[{x:-1,y:0,rotation:0},{x:0,y:-1,rotation:Math.PI/2*3},{x:0,y:1,rotation:Math.PI/2},{x:1,y:0,rotation:Math.PI}],[2],[1],[0,3]),"dance-double":new N("dance-double",[{x:0,y:1,rotation:0},{x:1,y:0,rotation:Math.PI/2*3},{x:1,y:2,rotation:Math.PI/2},{x:2,y:1,rotation:Math.PI},{x:3,y:1,rotation:0},{x:4,y:0,rotation:Math.PI/2*3},{x:4,y:2,rotation:Math.PI/2},{x:5,y:1,rotation:Math.PI}],[2,6],[1,5],[0,3,4,7])};class D{layout;WEIGHTS;constructor(t,s=void 0){this.layout=G[t],s!=null?this.WEIGHTS={...s}:this.WEIGHTS={...x}}setWeights(t){this.WEIGHTS={...this.WEIGHTS,...t}}getPlacementData(t,s,o,e){const i=[],l=[];for(let S=0;S<this.layout.layout.length;S++)o&&o.holds[S]===void 0&&t.action[S]!=n.NONE&&(i[t.action[S]]=!0),e.holds[S]===void 0&&s.action[S]!=n.NONE&&(l[s.action[S]]=!0);const r=i[n.LEFT_HEEL]||i[n.LEFT_TOE],a=i[n.RIGHT_HEEL]||i[n.RIGHT_TOE],c=l[n.LEFT_HEEL]||l[n.LEFT_TOE],d=l[n.RIGHT_HEEL]||l[n.RIGHT_TOE],f=l[n.LEFT_HEEL]&&l[n.LEFT_TOE],T=l[n.RIGHT_HEEL]&&l[n.RIGHT_TOE],g=i[n.LEFT_HEEL]&&i[n.RIGHT_HEEL],C=l[n.LEFT_HEEL]&&l[n.RIGHT_HEEL],w=!C&&this.doFeetOverlap(t.leftHeel,t.leftToe,s.leftHeel,s.leftToe)&&r&&c,p=!C&&this.doFeetOverlap(t.rightHeel,t.rightToe,s.rightHeel,s.rightToe)&&a&&d,O=r&&c&&!C&&!w&&!g,I=a&&d&&!C&&!p&&!g,y=this.layout.averagePoint(t.leftHeel,t.leftToe),b=this.layout.averagePoint(t.rightHeel,t.rightToe),R=this.layout.averagePoint(s.leftHeel,s.leftToe),L=this.layout.averagePoint(s.rightHeel,s.rightToe);return{previousLeftPos:y,previousRightPos:b,leftPos:R,rightPos:L,movedLeft:c,movedRight:d,leftBracket:f,rightBracket:T,previousJumped:g,jumped:C,leftJack:w,rightJack:p,leftDoubleStep:O,rightDoubleStep:I,initialState:t,resultState:s}}getActionCost(t,s,o,e){const i=o[e-1],l=o[e],r=s.second-t.second,a={},c=this.getPlacementData(t,s,i,l);a.MINE=this.calcMineCosts(c,l),a.HOLDSWITCH=this.calcHoldSwitchCosts(c,l),a.BRACKETTAP=this.calcBracketTapCost(c,r),a.BRACKETJACK=this.calcBracketJackCost(c),a.XO_BR=this.calcXOBRCost(c),a.DOUBLESTEP=this.calcDoublestepCost(c,i,l),a.JUMP=this.calcJumpCost(c,r),a.SLOW_BRACKET=this.calcSlowBracketCost(c,r),a.TWISTED_FOOT=this.calcTwistedFoot(c),a.FACING=this.calcFacingCost(c),a.SPIN=this.calcSpinCost(c),a.FOOTSWITCH=this.calcSlowFootswitchCost(c,l,r),a.SIDESWITCH=this.calcSideswitchCost(c),a.MISSED_FOOTSWITCH=this.calcMissedFootswitchCost(c,l),a.JACK=this.calcJackCost(c,r),a.DISTANCE=this.calcDistanceCost(c,r),a.CROWDED_BRACKET=this.calcCrowdedBracketCost(c,r);let d=0;for(const f in a)d+=a[f];return a.TOTAL=d,a}doesLeftFootOverlapRight(t){return t.resultState.rightHeel==-1?!1:t.resultState.rightHeel==t.resultState.leftHeel||t.resultState.rightHeel==t.resultState.leftToe?!0:t.resultState.rightToe==-1?!1:t.resultState.rightToe==t.resultState.leftHeel||t.resultState.rightToe==t.resultState.leftToe}doesRightFootOverlapLeft(t){return t.resultState.leftHeel==-1?!1:t.resultState.leftHeel==t.resultState.rightHeel||t.resultState.leftHeel==t.resultState.rightToe?!0:t.resultState.leftToe==-1?!1:t.resultState.leftToe==t.resultState.rightHeel||t.resultState.leftToe==t.resultState.rightToe}doFeetOverlap(t,s,o,e){return t!=-1&&(t==o||t==e)||s!=-1&&(s==o||s==e)}calcMineCosts(t,s){for(let o=0;o<this.layout.layout.length;o++)if(t.resultState.combinedColumns[o]!=n.NONE&&s.mines[o]!==void 0)return this.WEIGHTS.MINE;return 0}calcHoldSwitchCosts(t,s){let o=0;for(let e=0;e<s.holds.length;e++){if(s.holds[e]===void 0||s.holds[e].beat<t.initialState.beat)continue;const i=t.initialState.combinedColumns[e],l=t.resultState.combinedColumns[e];if(i!=l){const r=this.WEIGHTS.HOLDSWITCH*(t.resultState.footColumns[i]==-1?1:Math.sqrt(this.layout.getDistanceSq(e,t.resultState.footColumns[i])));o+=r}}return o}calcBracketTapCost(t,s){let o=0;if(t.resultState.leftHeel!=-1&&t.resultState.leftToe!=-1){let e=1;(t.initialState.movedFeet.has(n.LEFT_HEEL)||t.initialState.movedFeet.has(n.LEFT_TOE))&&(e=1/s),t.resultState.holdFeet.has(n.LEFT_HEEL)!=t.resultState.holdFeet.has(n.LEFT_TOE)&&(o+=this.WEIGHTS.BRACKETTAP*e)}if(t.resultState.rightHeel!=-1&&t.resultState.rightToe!=-1){let e=1;(t.initialState.movedFeet.has(n.RIGHT_HEEL)||t.initialState.movedFeet.has(n.RIGHT_TOE))&&(e=1/s),t.resultState.holdFeet.has(n.RIGHT_HEEL)!=t.resultState.holdFeet.has(n.RIGHT_TOE)&&(o+=this.WEIGHTS.BRACKETTAP*e)}return o}calcMovingFootWhileOtherIsntOnPadCost(t,s){let o=0;if(t.combinedColumns.some(e=>e!=n.NONE))for(const e of s.movedFeet)switch(e){case n.LEFT_HEEL:case n.LEFT_TOE:t.combinedColumns.includes(n.RIGHT_HEEL)||t.combinedColumns.includes(n.RIGHT_TOE)||(o+=this.WEIGHTS.OTHER);break;case n.RIGHT_HEEL:case n.RIGHT_TOE:t.combinedColumns.includes(n.LEFT_HEEL)||t.combinedColumns.includes(n.LEFT_TOE)||(o+=this.WEIGHTS.OTHER);break}return o}calcBracketJackCost(t){return t.jumped?0:t.leftJack&&t.leftBracket||t.rightJack&&t.rightBracket?this.WEIGHTS.BRACKETJACK:0}calcXOBRCost(t){let s=0;const o=t.rightPos.x<t.leftPos.x;return t.leftBracket&&o&&(s+=this.WEIGHTS.XO_BR),t.rightBracket&&o&&(s+=this.WEIGHTS.XO_BR),s}calcDoublestepCost(t,s,o){if(t.leftDoubleStep||t.rightDoubleStep){for(let e=0;e<this.layout.layout.length;e++)if(s.holds[e]&&!s.holdTails.has(e)||o.holds[e]!==void 0)return 0;return this.WEIGHTS.DOUBLESTEP}return 0}calcJumpCost(t,s){return t.jumped?this.WEIGHTS.JUMP/s:0}slowBracketThreshold=.15;calcSlowBracketCost(t,s){return s>this.slowBracketThreshold&&(t.leftBracket||t.rightBracket)&&!t.jumped?(s-this.slowBracketThreshold)*this.WEIGHTS.SLOW_BRACKET:0}calcTwistedFoot(t){const s=t.rightPos.x<t.leftPos.x,o=t.resultState.rightHeel!=-1&&t.resultState.rightToe!=-1?this.layout.layout[t.resultState.rightToe].y<this.layout.layout[t.resultState.rightHeel].y:!1,e=t.resultState.leftHeel!=-1&&t.resultState.leftToe!=-1?this.layout.layout[t.resultState.leftToe].y<this.layout.layout[t.resultState.leftHeel].y:!1;return!s&&(o||e)?this.WEIGHTS.TWISTED_FOOT:0}calcFacingCost(t){let s=0;const o=t.resultState.leftHeel!=-1&&t.resultState.rightHeel!=-1?this.layout.getFacingDirectionCosine(t.resultState.leftHeel,t.resultState.rightHeel):0,e=Math.pow(-Math.min(o,0),7.2)*200;return e>0&&(s+=e*this.WEIGHTS.FACING),s}calcSpinCost(t){let s=0;return t.rightPos.x<t.leftPos.x&&t.previousRightPos.x<t.previousLeftPos.x&&t.rightPos.y<t.leftPos.y&&t.previousRightPos.y>t.previousLeftPos.y&&(s+=this.WEIGHTS.SPIN),t.rightPos.x<t.leftPos.x&&t.previousRightPos.x<t.previousLeftPos.x&&t.rightPos.y>t.leftPos.y&&t.previousRightPos.y<t.previousLeftPos.y&&(s+=this.WEIGHTS.SPIN),s}SlowFootswitchThreshold=.2;SlowFootswitchIgnore=.4;calcSlowFootswitchCost(t,s,o){if(o<this.SlowFootswitchThreshold||o>=this.SlowFootswitchIgnore||s.mines.some(i=>i!==void 0)||s.fakeMines.some(i=>i!==void 0))return 0;let e=0;for(const i of t.resultState.movedFeet){const l=t.resultState.footColumns[i];t.initialState.combinedColumns[l]!=n.NONE&&(t.initialState.combinedColumns[l]==i||t.initialState.combinedColumns[l]==v[i]||(e+=(o-this.SlowFootswitchThreshold)/o*this.WEIGHTS.FOOTSWITCH))}return e}calcSideswitchCost(t){let s=0;return this.layout.sideArrows.forEach(o=>{t.resultState.action[o]!=n.NONE&&t.initialState.combinedColumns[o]!=n.NONE&&(t.initialState.combinedColumns[o]==t.resultState.action[o]||t.initialState.combinedColumns[o]==v[t.resultState.action[o]]||(s+=this.WEIGHTS.SIDESWITCH))}),s}calcMissedFootswitchCost(t,s){return(t.leftJack||t.rightJack)&&(s.mines.some(o=>o!==void 0)||s.fakeMines.some(o=>o!==void 0))?this.WEIGHTS.MISSED_FOOTSWITCH:0}JackMaxElapsedTime=.125;calcJackCost(t,s){return s<this.JackMaxElapsedTime&&(t.leftJack||t.rightJack)&&!t.previousJumped?(1/s-1/this.JackMaxElapsedTime)*this.WEIGHTS.JACK:0}calcDistanceCost(t,s){let o=0;for(const e of[n.LEFT_HEEL,n.RIGHT_HEEL]){if(!t.resultState.movedFeet.has(e))continue;const i=e==n.LEFT_HEEL?t.previousLeftPos:t.previousRightPos,l=e==n.LEFT_HEEL?t.leftPos:t.rightPos;if(e==n.LEFT_HEEL?t.leftBracket:t.rightBracket){const c=t.initialState.footColumns[e],d=t.initialState.footColumns[v[e]],f=t.resultState.footColumns[e];let T=t.resultState.footColumns[v[e]];if(T==-1&&(T=f),c!=-1&&(c==f||c==T)||d!=-1&&(d==f||d==T))continue}t.previousJumped&&!t.jumped&&s<.25&&(s=Math.pow(s,1.5));const a=Math.sqrt(this.layout.getDistanceSqPoints(i,l))*this.WEIGHTS.DISTANCE/s;o+=a}return o}calcCrowdedBracketCost(t,s){let o=0;return t.leftBracket&&this.doesLeftFootOverlapRight(t)&&(o+=this.WEIGHTS.CROWDED_BRACKET/s),t.rightBracket&&this.doesRightFootOverlapLeft(t)&&(o+=this.WEIGHTS.CROWDED_BRACKET/s),o}}const B=5e-4;class _{children=new Map;state;key;constructor(t,s){this.state=t,s?this.key=s:this.key=t.toKey()}}class W{costCalc;layout;initialRow={notes:[],holds:[],holdTails:new Set,mines:[],fakeMines:[],second:-1,beat:-1,columns:[],overrides:[],id:"start"};endRow={notes:[],holds:[],holdTails:new Set,mines:[],fakeMines:[],second:-1,beat:-1,columns:[],overrides:[],id:"end"};initialNode;endNode;cachedEdges=new Map;cachedLowestCost=new Map;edgeCacheSize=0;permuteCache=new Map;nodeMap=new Map;nEdges=0;bestPath;bestPathCost=0;bestPathSet;debugStats={lastUpdatedRowStart:-1,lastUpdatedOldRowEnd:-1,lastUpdatedRowEnd:-1,rowUpdateTime:0,lastUpdatedNodeStart:-1,lastUpdatedNodeEnd:-1,nodeUpdateTime:0,createdNodes:0,createdEdges:0,calculatedEdges:0,cachedEdges:0,edgeUpdateTime:0,cachedBestRows:0,pathUpdateTime:0};notedataRows=[];nodeRows=[];constructor(t){if(this.notedataRows=[],this.layout=G[t],!this.layout)throw new Error(`Unsupported game type: ${t}`);this.costCalc=new D(t),this.initialNode=new _(new P(this.initialRow,[],new Array(5).fill(-1))),this.endNode=new _(new P(this.endRow,[],new Array(5).fill(-1)))}compute(t,s,o){if(this.layout==null)return null;const e=this.recalculateRows(t,s,o),i=this.recalculateStates(e),l=this.computeCosts(i);if(this.computeBestPath(l),this.edgeCacheSize>this.nEdges*2){this.edgeCacheSize=0;const d=new Map;for(const f of this.nodeRows)for(const T of f.nodes)for(const[g,C]of T.children.entries()){let w=d.get(T.key);w||(w=new Map,d.set(T.key,w)),w.set(g,C),this.edgeCacheSize++}this.cachedEdges=d}if(this.cachedLowestCost.size>this.nodeMap.size*2&&this.cachedLowestCost.clear(),!this.bestPath)return null;const a=new Map;this.notedataRows.forEach((d,f)=>{this.nodeMap.get(this.bestPath[f+1]).state.combinedColumns.forEach((g,C)=>{g!=n.NONE&&d.notes[C]&&a.set(d.notes[C].beat.toFixed(3)+"-"+C,g)})});const c=this.bestPath.map((d,f)=>f==0?this.initialNode.state:f==this.bestPath.length-1?this.endNode.state:this.nodeMap.get(d).state);return{labels:a,states:c}}recalculateRows(t,s,o){const e=performance.now(),i=M(this.notedataRows,Math.round(t*48),Math.round(s*48),h=>Math.round(h.beat*48)),l=i[0];let r=i[1];const[a,c]=M(o,Math.round(t*48),Math.round(s*48),h=>Math.round(h.beat*48)),d=o.slice(a,c);let f=[],T=[],g=[],C=[],w=[],p=a-1;const O=new Array(this.layout.columnCount).fill(0);let I=0;for(;p>=0&&I<O.length;){const h=o[p];if(O[h.col]==1){p--;continue}if(h.type=="Mine"&&I==0){h.fake?g[h.col]===void 0&&(w[h.col]=h.second):T[h.col]===void 0&&(C[h.col]=h.second),p--;continue}if(h.fake||h.warped){p--;continue}O[h.col]=1,I++,F(h)&&(f[h.col]=h),p--}let y=null,b=null,R=[],L=[];const S=[];for(const h of d){if(h.type=="Mine"){this.isSameSecond(h.second,y)&&S.length>0?h.fake?g[h.col]=h.second:T[h.col]=h.second:h.fake?w[h.col]=h.second:C[h.col]=h.second;continue}h.fake||h.warped||(this.isSameSecond(y,h.second)||(y!=null&&b!=null&&(S.push({notes:R,holds:f.map(m=>{if(!(m===void 0||this.isSameSecond(m.second,y)||m.second>y))return m}),holdTails:new Set(f.filter(m=>!(m===void 0||Math.abs(m.beat+m.hold-b)>5e-4)).map(m=>m.col)),mines:T,fakeMines:g,second:y,beat:b,columns:[],overrides:L,id:""}),S.at(-1).id=this.rowToKey(S.at(-1))),y=h.second,b=h.beat,R=[],L=[],T=C,g=w,C=[],w=[],f=f.map(m=>{if(!(m===void 0||Math.round(h.beat*48)>Math.round((m.beat+m.hold)*48)))return m})),R[h.col]=h,h.parity?.override&&(L[h.col]=h.parity?.override),F(h)&&(f[h.col]=h))}if(R.length!=0&&(S.push({notes:R,holds:f.map(h=>{if(!(h===void 0||this.isSameSecond(h.second,y)||h.second>y))return h}),holdTails:new Set(f.filter(h=>!(h===void 0||Math.abs(h.beat+h.hold-b)>5e-4)).map(h=>h.col)),mines:T,fakeMines:g,second:y,beat:b,columns:[],overrides:L,id:""}),S.at(-1).id=this.rowToKey(S.at(-1))),this.notedataRows[r]){this.notedataRows[r].mines=C,this.notedataRows[r].fakeMines=w;const h=this.notedataRows[r].id;this.notedataRows[r].id=this.rowToKey(this.notedataRows[r]),h!=this.notedataRows[r].id&&(S.push(this.notedataRows[r]),r++)}return this.debugStats.lastUpdatedRowStart=l,this.debugStats.lastUpdatedOldRowEnd=r,this.debugStats.lastUpdatedRowEnd=l+S.length,this.notedataRows.splice(l,r-l,...S),this.debugStats.rowUpdateTime=performance.now()-e,{startIdx:l,newEndIdx:l+S.length,oldEndIdx:r}}recalculateStates(t){this.debugStats.createdNodes=0,this.debugStats.createdEdges=0;const s=performance.now();this.nodeRows.splice(t.startIdx,t.oldEndIdx-t.startIdx).forEach(i=>{i.nodes.forEach(l=>{this.nodeMap.delete(l.key),this.nEdges-=l.children.size})});let e=t.startIdx??0;for(e-=1,this.debugStats.lastUpdatedNodeStart=e;e<this.notedataRows.length-1;){let i=this.nodeRows[e]?.nodes??[this.initialNode];const l=new Set;for(const a of i){this.nEdges-=a.children.size,a.children.clear();let c=this.getPossibleActions(this.notedataRows[e+1]);this.notedataRows[e+1].overrides.some(d=>d)&&(c=this.filterActions(this.notedataRows[e+1],c,this.notedataRows[e+1].overrides));for(const d of c){const f=this.initResultState(a.state,this.notedataRows[e+1],d),T=f.toKey();let g=this.nodeMap.get(T);g||(g=new _(f,T),this.nodeMap.set(T,g)),l.add(g),this.debugStats.createdEdges+=1,this.nEdges++,a.children.set(g.key,{})}}const r=Array.from(l);if(this.debugStats.createdNodes+=r.length,e+1>=t.newEndIdx){const a=this.nodeRows[e+1];if(a&&a.nodes.length==l.size){a.nodes.sort(),r.sort();let c=!0;for(let d=0;d<a.nodes.length;d++)if(a.nodes[d].key!=r[d].key){c=!1;break}if(c)break}this.nodeRows[e+1]={beat:this.notedataRows[e+1].beat,nodes:r}}else this.nodeRows.splice(e+1,0,{beat:this.notedataRows[e+1].beat,nodes:r});i=r,e++}return this.debugStats.lastUpdatedNodeEnd=e+1,this.debugStats.nodeUpdateTime=performance.now()-s,{firstUpdatedRow:this.debugStats.lastUpdatedNodeStart,lastUpdatedRow:this.debugStats.lastUpdatedNodeEnd}}computeCosts(t){this.debugStats.calculatedEdges=0,this.debugStats.cachedEdges=0;const s=performance.now();let o=t.firstUpdatedRow-1;for(o<-1&&(o=-1);o<this.notedataRows.length-1&&o<t.lastUpdatedRow;){const e=this.nodeRows[o]?.nodes??[this.initialNode];for(const i of e)for(const l of i.children.keys()){const r=this.nodeMap.get(l);if(!r){console.warn("Child node not found for key:",l);continue}const a=r.state,c=i.state;if(this.debugStats.calculatedEdges++,this.cachedEdges.has(i.key)&&this.cachedEdges.get(i.key).has(l)){this.debugStats.cachedEdges++,i.children.set(l,this.cachedEdges.get(i.key).get(l));continue}this.edgeCacheSize++;const d=this.costCalc.getActionCost(c,a,this.notedataRows,o+1);let f=this.cachedEdges.get(i.key);f||(f=new Map,this.cachedEdges.set(i.key,f)),f.set(l,d),i.children.set(l,d)}o++}return this.debugStats.edgeUpdateTime=performance.now()-s,Math.max(-1,t.firstUpdatedRow-1)}computeBestPath(t){const s=performance.now();this.cachedLowestCost.set(this.initialNode.key,{cost:0,path:this.initialNode.key});let o=t;this.debugStats.cachedBestRows=t+1;const e=new Map;for(;o<this.notedataRows.length;){e.clear();const i=this.nodeRows[o]?.nodes??[this.initialNode];for(const l of i){const r=this.cachedLowestCost.get(l.key)?.cost;if(r===void 0){console.warn("No cost found for node:",l.key);continue}o==this.notedataRows.length-1&&l.children.set(this.endNode.key,{TOTAL:0});for(const[a,c]of l.children.entries()){const d=e.get(a);(d===void 0||r+c.TOTAL<d)&&(this.cachedLowestCost.set(a,{cost:r+c.TOTAL,path:this.cachedLowestCost.get(l.key).path+"*"+a}),e.set(a,r+c.TOTAL))}o==this.notedataRows.length-1&&l.children.delete(this.endNode.key)}o++}this.bestPath=this.cachedLowestCost.get(this.endNode.key)?.path.split("*")??[],this.bestPathCost=this.cachedLowestCost.get(this.endNode.key)?.cost??0,this.bestPath||console.error("No best path found"),this.bestPathSet=new Set(this.bestPath??[]),this.debugStats.pathUpdateTime=performance.now()-s}calculatePermuteColumnKey(t){let s="";for(let o=0;o<this.layout.columnCount;o++)(t.notes[o]||t.holds[o])&&(s+=o);return s}getPossibleActions(t){const s=this.calculatePermuteColumnKey(t);let o=this.permuteCache.get(s);return o==null&&(o=this.generateActions(t,new Array(this.layout.columnCount).fill(n.NONE),0),this.permuteCache.set(s,o)),this.permuteCache.get(s)}generateActions(t,s,o){if(o>=s.length){let i=-1,l=-1,r=-1,a=-1;for(let c=0;c<s.length;c++)s[c]!=n.NONE&&(s[c]==n.LEFT_HEEL&&(i=c),s[c]==n.LEFT_TOE&&(l=c),s[c]==n.RIGHT_HEEL&&(r=c),s[c]==n.RIGHT_TOE&&(a=c));return i==-1&&l!=-1||r==-1&&a!=-1?[]:i!=-1&&l!=-1&&!this.layout.bracketCheck(i,l)?[]:r!=-1&&a!=-1&&!this.layout.bracketCheck(r,a)?[]:[s]}const e=[];if(t.notes[o]||t.holds[o]){for(const i of H){if(s.includes(i))continue;const l=[...s];l[o]=i,e.push(...this.generateActions(t,l,o+1))}return e}return this.generateActions(t,s,o+1)}filterActions(t,s,o){const e=new Array(H.length+1).fill(0),i={Left:0,Right:0};for(const r of o)typeof r=="number"?e[r]++:typeof r=="string"&&i[r]++;for(let r=1;r<H.length;r++)if(e[r]>1)return console.warn(`Could not generate any valid permutations with parity overrides for row at beat ${t.beat}, clearing overrides, as there must be something invalid about it.`),s;if(i.Left+e[n.LEFT_HEEL]+e[n.LEFT_TOE]>2||i.Right+e[n.RIGHT_HEEL]+e[n.RIGHT_TOE]>2)return console.warn(`Could not generate any valid permutations with parity overrides for row at beat ${t.beat}, clearing overrides, as there must be something invalid about it.`),s;const l=s.filter(r=>{for(let a=0;a<this.layout.columnCount;a++){const c=o[a];if(!(c==null||c==n.NONE)){if(c=="Left"){if(r[a]!=n.LEFT_HEEL&&r[a]!=n.LEFT_TOE)return!1}else if(c=="Right"){if(r[a]!=n.RIGHT_HEEL&&r[a]!=n.RIGHT_TOE)return!1}else if(r[a]!=c)return!1}}return!0});return l.length==0?(console.warn(`Could not generate any valid permutations with parity overrides for row at beat ${t.beat}, clearing overrides, as there must be something invalid about it.`),s):l}initResultState(t,s,o){const e=new P(s,o,new Array(5).fill(-1));for(let i=0;i<this.layout.columnCount;i++)e.combinedColumns.push(n.NONE),!(o[i]==null||o[i]==n.NONE)&&(e.footColumns[o[i]]=i,e.combinedColumns[i]=o[i],(s.holds[i]==null||t.combinedColumns[i]!=o[i])&&e.movedFeet.add(o[i]),s.holds[i]!=null&&e.holdFeet.add(o[i]));return e.footColumns[n.LEFT_HEEL]==-1&&(e.footColumns[n.LEFT_HEEL]=t.footColumns[n.LEFT_HEEL],e.footColumns[n.LEFT_TOE]=t.footColumns[n.LEFT_TOE],e.combinedColumns[e.footColumns[n.LEFT_HEEL]]==n.NONE&&(e.combinedColumns[e.footColumns[n.LEFT_HEEL]]=n.LEFT_HEEL),e.combinedColumns[e.footColumns[n.LEFT_TOE]]==n.NONE&&(e.combinedColumns[e.footColumns[n.LEFT_TOE]]=n.LEFT_TOE)),e.footColumns[n.RIGHT_HEEL]==-1&&(e.footColumns[n.RIGHT_HEEL]=t.footColumns[n.RIGHT_HEEL],e.footColumns[n.RIGHT_TOE]=t.footColumns[n.RIGHT_TOE],e.combinedColumns[e.footColumns[n.RIGHT_HEEL]]==n.NONE&&(e.combinedColumns[e.footColumns[n.RIGHT_HEEL]]=n.RIGHT_HEEL),e.combinedColumns[e.footColumns[n.RIGHT_TOE]]==n.NONE&&(e.combinedColumns[e.footColumns[n.RIGHT_TOE]]=n.RIGHT_TOE)),e}rowToKey(t){let s="";for(let r=0;r<this.layout.columnCount;r++)t.notes[r]&&(s+=r+"|");const o=t.fakeMines.map((r,a)=>r===void 0?"0":a+"|"+r.toFixed(3)).join("^"),e=t.mines.map((r,a)=>r===void 0?"0":a+"|"+r.toFixed(3)).join("^");let i="";for(let r=0;r<this.layout.columnCount;r++)t.holdTails.has(r)?i+=r+"T":t.holds[r]!==void 0&&(i+=r+"H");i=i.replace(/0+$/,"");let l="";for(let r=0;r<this.layout.columnCount;r++)t.overrides[r]!==void 0&&(l+=r+""+t.overrides[r]);return`${t.beat.toFixed(3)}-${s}-${o}-${e}-${i}-${l}`}isSameSecond(t,s){return t===null||s===null?!1:Math.abs(t-s)<B}deleteCache(){this.cachedEdges.clear(),this.cachedLowestCost.clear(),this.edgeCacheSize=0,this.permuteCache.clear()}reset(){this.bestPath=void 0,this.bestPathCost=0,this.bestPathSet=void 0,this.nodeMap.clear(),this.nEdges=0,this.nodeRows=[],this.notedataRows=[],this.deleteCache()}}let E;function U(){return E?{edgeCacheSize:E.edgeCacheSize,nodeMap:E.nodeMap,bestPath:E.bestPath,bestPathCost:E.bestPathCost,bestPathSet:E.bestPathSet,notedataRows:E.notedataRows,nodeRows:E.nodeRows,stats:E.debugStats}:null}function K(){return E?{removedRowsStart:E.debugStats.lastUpdatedRowStart,removedRowsEnd:E.debugStats.lastUpdatedOldRowEnd,newRows:E.notedataRows.slice(E.debugStats.lastUpdatedRowStart,E.debugStats.lastUpdatedRowEnd),newStates:E.nodeRows.slice(Math.max(0,E.debugStats.lastUpdatedNodeStart),E.debugStats.lastUpdatedNodeEnd),bestPath:E.bestPath,bestPathCost:E.bestPathCost,bestPathSet:E.bestPathSet,edgeCacheSize:E.edgeCacheSize,stats:E.debugStats}:null}self.onmessage=u=>{switch(u.data.type){case"init":if(E){postMessage({type:"init",id:u.data.id,success:!1,error:"Instance already initialized"});return}try{E=new W(u.data.gameType),postMessage({type:"init",id:u.data.id,success:!0})}catch(t){postMessage({type:"init",id:u.data.id,success:!1,error:t.message})}break;case"compute":{if(!E){postMessage({type:"compute",id:u.data.id,success:!1,error:"Instance not initialized",parityLabels:null,bestStates:null});return}const t=E.compute(u.data.startBeat,u.data.endBeat,u.data.notedata);if(!t){postMessage({type:"compute",id:u.data.id,success:!1,error:"No path found",parityLabels:null,bestStates:null});return}postMessage({type:"compute",id:u.data.id,success:!0,parityLabels:t.labels,bestStates:t.states,debug:u.data.debug?K():void 0});break}case"getDebug":{if(!E){postMessage({type:"getDebug",id:u.data.id,success:!1,error:"Instance not initialized",data:null});return}postMessage({type:"getDebug",id:u.data.id,success:!0,data:U()});break}}}})();
