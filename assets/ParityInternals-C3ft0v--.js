(function(){"use strict";const U=["Hold","Roll"];function N(l){return U.includes(l.type)}function W(l,t,s){return Math.max(t,Math.min(s,l))}var r=(l=>(l[l.NONE=0]="NONE",l[l.LEFT_HEEL=1]="LEFT_HEEL",l[l.LEFT_TOE=2]="LEFT_TOE",l[l.RIGHT_HEEL=3]="RIGHT_HEEL",l[l.RIGHT_TOE=4]="RIGHT_TOE",l))(r||{});const L=[1,2,3,4],I=[0,2,1,4,3],J={DOUBLESTEP:750,BRACKETJACK:60,JACK:40,JUMP:0,SLOW_BRACKET:300,TWISTED_FOOT:1e5,BRACKETTAP:400,XO_BR:200,HOLDSWITCH:55,MINE:1e4,FOOTSWITCH:325,MISSED_FOOTSWITCH:500,FACING:3,DISTANCE:6,SPIN:3e3,SIDESWITCH:130,CROWDED_BRACKET:0,OTHER:0,START_XO:1e4};var y=(l=>(l[l.Crossovers=0]="Crossovers",l[l.Footswitches=1]="Footswitches",l[l.Sideswitches=2]="Sideswitches",l[l.Jacks=3]="Jacks",l[l.Brackets=4]="Brackets",l[l.Doublesteps=5]="Doublesteps",l[l.Holdswitch=6]="Holdswitch",l))(y||{}),v=(l=>(l[l.UnmarkedDoublestep=0]="UnmarkedDoublestep",l[l.MissedFootswitch=1]="MissedFootswitch",l[l.Ambiguous=2]="Ambiguous",l))(v||{});Object.fromEntries(Object.entries({0:"DS",1:"FS",2:"AM"}).map(([l,t])=>[t,Number(l)]));class P{action=[];combinedColumns=[];movedFeet=new Set;holdFeet=new Set;frontFoot=null;second;beat;rowKey;footColumns=[];constructor(t,s,o=[]){this.second=t.second,this.beat=t.beat,this.rowKey=t.id,this.action=[...s],this.footColumns=[...o]}get leftHeel(){return this.footColumns[1]}get leftToe(){return this.footColumns[2]}get rightHeel(){return this.footColumns[3]}get rightToe(){return this.footColumns[4]}toKey(){let t="";for(let e=0;e<L.length;e++)this.movedFeet.has(L[e])&&(t+=L[e]);let s="";for(let e=0;e<L.length;e++)this.holdFeet.has(L[e])&&(s+=L[e]);let o="";for(let e=1;e<this.footColumns.length;e++)this.footColumns[e]!==-1?o+=this.footColumns[e]:o+=".";return`${this.rowKey}-${this.action.join("")}-${this.combinedColumns.join("")}-${t}-${s}-${o}-${this.frontFoot}`}}function A(l,t,s,o){return l!=-1&&(l==s||l==o)||t!=-1&&(t==s||t==o)}function _(l,t){const s=t.x-l.x,o=t.y-l.y,e=1,i=0,a=s*e+o*i,n=s*i-o*e;return Math.atan2(n,a)}class G{name;layout;columnCount;upArrows;downArrows;sideArrows;constructor(t,s,o,e,i){this.name=t,this.layout=s,this.columnCount=s.length,this.upArrows=o,this.downArrows=e,this.sideArrows=i}getFacingDirectionCosine(t,s){if(t==s)return 0;let o=this.layout[s].x-this.layout[t].x;const e=this.layout[s].y-this.layout[t].y,i=Math.sqrt(o*o+e*e);return o/=i,o}getYDifference(t,s){if(t==s)return 0;const o=this.layout[s].x-this.layout[t].x;let e=this.layout[s].y-this.layout[t].y;const i=Math.sqrt(o*o+e*e);e/=i;const a=e<=0;return e=Math.pow(e,4),a&&(e=-e),e}averagePoint(t,s){return t==-1&&s==-1?{x:0,y:0}:t==-1?this.layout[s]:s==-1?this.layout[t]:{x:(this.layout[t].x+this.layout[s].x)/2,y:(this.layout[t].y+this.layout[s].y)/2}}getDistanceSq(t,s){const o=this.layout[t],e=this.layout[s];return(o.y-e.y)*(o.y-e.y)+(o.x-e.x)*(o.x-e.x)}getDistanceSqPoints(t,s){return(t.y-s.y)*(t.y-s.y)+(t.x-s.x)*(t.x-s.x)}bracketCheck(t,s){return this.getDistanceSq(t,s)<=2}getPlayerAngle(t,s){const o=this.layout[t],e=this.layout[s],i=e.x-o.x,a=e.y-o.y,n=1,h=0,c=i*n+a*h,f=i*h-a*n;return Math.atan2(f,c)}getPlacementData(t,s,o,e){const i=[],a=[];for(let H=0;H<this.layout.length;H++)o&&o.holds[H]===void 0&&t.action[H]!=r.NONE&&(i[t.action[H]]=!0),e.holds[H]===void 0&&s.action[H]!=r.NONE&&(a[s.action[H]]=!0);const n=i[r.LEFT_HEEL]||i[r.LEFT_TOE],h=i[r.RIGHT_HEEL]||i[r.RIGHT_TOE],c=a[r.LEFT_HEEL]||a[r.LEFT_TOE],f=a[r.RIGHT_HEEL]||a[r.RIGHT_TOE],E=a[r.LEFT_HEEL]&&a[r.LEFT_TOE],g=a[r.RIGHT_HEEL]&&a[r.RIGHT_TOE],m=i[r.LEFT_HEEL]&&i[r.RIGHT_HEEL],d=a[r.LEFT_HEEL]&&a[r.RIGHT_HEEL],T=!d&&A(t.leftHeel,t.leftToe,s.leftHeel,s.leftToe)&&n&&c,w=!d&&A(t.rightHeel,t.rightToe,s.rightHeel,s.rightToe)&&h&&f,C=n&&c&&!d&&!T&&!m,b=h&&f&&!d&&!w&&!m,p=this.averagePoint(t.leftHeel,t.leftToe),M=this.averagePoint(t.rightHeel,t.rightToe),O=this.averagePoint(s.leftHeel,s.leftToe),k=this.averagePoint(s.rightHeel,s.rightToe);return{previousLeftPos:p,previousRightPos:M,leftPos:O,rightPos:k,movedLeft:c,movedRight:f,leftBracket:E,rightBracket:g,previousJumped:m,jumped:d,leftJack:T,rightJack:w,leftDoubleStep:C,rightDoubleStep:b,initialState:t,resultState:s}}}const D={"dance-single":new G("dance-single",[{x:-1,y:0,rotation:0},{x:0,y:-1,rotation:Math.PI/2*3},{x:0,y:1,rotation:Math.PI/2},{x:1,y:0,rotation:Math.PI}],[2],[1],[0,3]),"dance-double":new G("dance-double",[{x:-2.5,y:0,rotation:0},{x:-1.5,y:-1,rotation:Math.PI/2*3},{x:-1.5,y:1,rotation:Math.PI/2},{x:-.5,y:0,rotation:Math.PI},{x:.5,y:0,rotation:0},{x:1.5,y:-1,rotation:Math.PI/2*3},{x:1.5,y:1,rotation:Math.PI/2},{x:2.5,y:0,rotation:Math.PI}],[2,6],[1,5],[0,3,4,7])};class K{layout;WEIGHTS;constructor(t,s=void 0){this.layout=D[t],s!=null?this.WEIGHTS={...s}:this.WEIGHTS={...J}}setWeights(t){this.WEIGHTS={...this.WEIGHTS,...t}}getActionCost(t,s,o,e){const i=o[e-1],a=o[e];let n=s.second-t.second;e==0&&(n=.1);const h={},c=this.layout.getPlacementData(t,s,i,a);h.MINE=this.calcMineCosts(c,a),h.HOLDSWITCH=this.calcHoldSwitchCosts(c,a),h.BRACKETTAP=this.calcBracketTapCost(c,n),h.OTHER=this.calcStartCrossover(c,e),h.BRACKETJACK=this.calcBracketJackCost(c),h.XO_BR=this.calcXOBRCost(c),h.DOUBLESTEP=this.calcDoublestepCost(c,i,a,n),h.JUMP=this.calcJumpCost(c,n),h.SLOW_BRACKET=this.calcSlowBracketCost(c,n),h.TWISTED_FOOT=this.calcTwistedFoot(c),h.FACING=this.calcFacingCost(c),h.SPIN=this.calcSpinCost(c),h.FOOTSWITCH=this.calcSlowFootswitchCost(c,a,n),h.SIDESWITCH=this.calcSideswitchCost(c),h.MISSED_FOOTSWITCH=this.calcMissedFootswitchCost(c,a),h.JACK=this.calcJackCost(c,n),h.DISTANCE=this.calcDistanceCost(c,n),h.CROWDED_BRACKET=this.calcCrowdedBracketCost(c,n);let f=0;for(const E in h)f+=h[E];return h.TOTAL=f,h}doesLeftFootOverlapRight(t){return t.resultState.rightHeel==-1?!1:t.resultState.rightHeel==t.resultState.leftHeel||t.resultState.rightHeel==t.resultState.leftToe?!0:t.resultState.rightToe==-1?!1:t.resultState.rightToe==t.resultState.leftHeel||t.resultState.rightToe==t.resultState.leftToe}doesRightFootOverlapLeft(t){return t.resultState.leftHeel==-1?!1:t.resultState.leftHeel==t.resultState.rightHeel||t.resultState.leftHeel==t.resultState.rightToe?!0:t.resultState.leftToe==-1?!1:t.resultState.leftToe==t.resultState.rightHeel||t.resultState.leftToe==t.resultState.rightToe}calcMineCosts(t,s){for(let o=0;o<this.layout.layout.length;o++)if(t.resultState.combinedColumns[o]!=r.NONE&&s.mines[o]!==void 0)return this.WEIGHTS.MINE;return 0}calcHoldSwitchCosts(t,s){let o=0;for(let e=0;e<s.holds.length;e++){if(s.holds[e]===void 0||s.holds[e].beat<t.initialState.beat)continue;const i=t.initialState.combinedColumns[e],a=t.resultState.combinedColumns[e];if(i!=a&&i!=I[a]){const n=this.WEIGHTS.HOLDSWITCH*(t.resultState.footColumns[i]==-1?1:Math.sqrt(this.layout.getDistanceSq(e,t.resultState.footColumns[i])));o+=n}}return o}calcBracketTapCost(t,s){let o=0;if(t.resultState.leftHeel!=-1&&t.resultState.leftToe!=-1){let e=1;(t.initialState.movedFeet.has(r.LEFT_HEEL)||t.initialState.movedFeet.has(r.LEFT_TOE))&&(e=1/s),t.resultState.holdFeet.has(r.LEFT_HEEL)!=t.resultState.holdFeet.has(r.LEFT_TOE)&&(o+=this.WEIGHTS.BRACKETTAP*e)}if(t.resultState.rightHeel!=-1&&t.resultState.rightToe!=-1){let e=1;(t.initialState.movedFeet.has(r.RIGHT_HEEL)||t.initialState.movedFeet.has(r.RIGHT_TOE))&&(e=1/s),t.resultState.holdFeet.has(r.RIGHT_HEEL)!=t.resultState.holdFeet.has(r.RIGHT_TOE)&&(o+=this.WEIGHTS.BRACKETTAP*e)}return o}calcStartCrossover(t,s){return t.rightPos.x<t.leftPos.x&&s==0?this.WEIGHTS.START_XO:0}calcBracketJackCost(t){return t.jumped?0:t.leftJack&&t.leftBracket||t.rightJack&&t.rightBracket?this.WEIGHTS.BRACKETJACK:0}calcXOBRCost(t){let s=0;const o=t.rightPos.x<t.leftPos.x;return t.leftBracket&&o&&(s+=this.WEIGHTS.XO_BR),t.rightBracket&&o&&(s+=this.WEIGHTS.XO_BR),s}calcDoublestepCost(t,s,o,e){if(t.leftDoubleStep||t.rightDoubleStep){for(let i=0;i<this.layout.layout.length;i++)if(s.holds[i]&&!s.holdTails.has(i)||o.holds[i]!==void 0)return 0;return t.leftDoubleStep&&(o.mines[t.initialState.footColumns[r.LEFT_HEEL]]||o.fakeMines[t.initialState.footColumns[r.LEFT_HEEL]]||o.mines[t.initialState.footColumns[r.LEFT_TOE]]||o.fakeMines[t.initialState.footColumns[r.LEFT_TOE]])||t.rightDoubleStep&&(o.mines[t.initialState.footColumns[r.RIGHT_HEEL]]||o.fakeMines[t.initialState.footColumns[r.RIGHT_HEEL]]||o.mines[t.initialState.footColumns[r.RIGHT_TOE]]||o.fakeMines[t.initialState.footColumns[r.RIGHT_TOE]])?0:this.WEIGHTS.DOUBLESTEP/W(e*4,.3,1)}return 0}calcJumpCost(t,s){return t.jumped?this.WEIGHTS.JUMP/s:0}slowBracketThreshold=.15;slowBracketCap=.5;calcSlowBracketCost(t,s){return s>this.slowBracketThreshold&&(t.leftBracket||t.rightBracket)&&!t.jumped?Math.min(this.slowBracketCap,s-this.slowBracketThreshold)*this.WEIGHTS.SLOW_BRACKET:0}calcTwistedFoot(t){const s=t.rightPos.x<t.leftPos.x,o=t.resultState.rightHeel!=-1&&t.resultState.rightToe!=-1?this.layout.layout[t.resultState.rightToe].y<this.layout.layout[t.resultState.rightHeel].y:!1,e=t.resultState.leftHeel!=-1&&t.resultState.leftToe!=-1?this.layout.layout[t.resultState.leftToe].y<this.layout.layout[t.resultState.leftHeel].y:!1;return!s&&(o||e)?this.WEIGHTS.TWISTED_FOOT:0}calcFacingCost(t){let s=0,o=t.rightPos.x-t.leftPos.x;const e=t.rightPos.y-t.leftPos.y,i=Math.sqrt(o*o+e*e);o/=i;const n=Math.pow(-Math.min(o,0),7.2)*200;return n>0&&(s+=n*this.WEIGHTS.FACING),s}calcSpinCost(t){let s=0,o=_(t.previousLeftPos,t.previousRightPos),e=_(t.leftPos,t.rightPos);return Math.abs(e)<Math.PI/2||Math.abs(o)<Math.PI/2||(e<0&&(e+=Math.PI*2),o<0&&(o+=Math.PI*2),e==o)?0:((o<=Math.PI&&e>=Math.PI||o>=Math.PI&&e<=Math.PI)&&t.initialState.frontFoot!=t.resultState.frontFoot&&(s+=this.WEIGHTS.SPIN),s)}SlowFootswitchThreshold=.2;SlowFootswitchIgnore=.4;calcSlowFootswitchCost(t,s,o){if(o<this.SlowFootswitchThreshold||o>=this.SlowFootswitchIgnore||t.jumped||s.mines.some(i=>i!==void 0)||s.fakeMines.some(i=>i!==void 0))return 0;let e=0;for(const i of t.resultState.movedFeet){const a=t.resultState.footColumns[i];t.initialState.combinedColumns[a]!=r.NONE&&(t.initialState.combinedColumns[a]==i||t.initialState.combinedColumns[a]==I[i]||(e+=(o-this.SlowFootswitchThreshold)/o*this.WEIGHTS.FOOTSWITCH))}return e}calcSideswitchCost(t){let s=0;return t.jumped?0:(this.layout.sideArrows.forEach(o=>{t.resultState.action[o]!=r.NONE&&t.initialState.combinedColumns[o]!=r.NONE&&(t.initialState.combinedColumns[o]==t.resultState.action[o]||t.initialState.combinedColumns[o]==I[t.resultState.action[o]]||(s+=this.WEIGHTS.SIDESWITCH))}),s)}calcMissedFootswitchCost(t,s){return(t.leftJack||t.rightJack)&&(s.mines.some(o=>o!==void 0)||s.fakeMines.some(o=>o!==void 0))?this.WEIGHTS.MISSED_FOOTSWITCH:0}JackMaxElapsedTime=.125;calcJackCost(t,s){return s<this.JackMaxElapsedTime&&(t.leftJack||t.rightJack)&&!t.previousJumped?(1/s-1/this.JackMaxElapsedTime)*this.WEIGHTS.JACK:0}calcDistanceCost(t,s){let o=0;for(const e of[r.LEFT_HEEL,r.RIGHT_HEEL]){if(!t.resultState.movedFeet.has(e))continue;const i=e==r.LEFT_HEEL?t.previousLeftPos:t.previousRightPos,a=e==r.LEFT_HEEL?t.leftPos:t.rightPos;if(e==r.LEFT_HEEL?t.leftBracket:t.rightBracket){const c=t.initialState.footColumns[e],f=t.initialState.footColumns[I[e]],E=t.resultState.footColumns[e];let g=t.resultState.footColumns[I[e]];if(g==-1&&(g=E),c!=-1&&(c==E||c==g)||f!=-1&&(f==E||f==g))continue}t.previousJumped&&!t.jumped&&s<.25&&(s=Math.pow(s,1.5));const h=Math.sqrt(this.layout.getDistanceSqPoints(i,a))*this.WEIGHTS.DISTANCE/s;o+=h}return o}calcCrowdedBracketCost(t,s){let o=0;return t.leftBracket&&this.doesLeftFootOverlapRight(t)&&(o+=this.WEIGHTS.CROWDED_BRACKET/s),t.rightBracket&&this.doesRightFootOverlapLeft(t)&&(o+=this.WEIGHTS.CROWDED_BRACKET/s),o}}function z(l,t,s){const o=[void 0],e=new Map,i=[],a=[],n=[0],h=new Map;for(let c=0;c<l.length-1;c++){const f=l[c].state,E=t[c],g=l[c+1].state,m=t[c+1],d=s.getPlacementData(f,g,E,m);n.push(_(d.leftPos,d.rightPos));const T=new Set,w=new Set;for(let C=0;C<m.holds.length;C++){if(m.holds[C]===void 0||m.holds[C].beat<d.initialState.beat)continue;const b=d.initialState.combinedColumns[C],p=d.resultState.combinedColumns[C];if(b!=p&&b!=I[p]){T.add(y.Holdswitch);break}}if(!T.has(y.Holdswitch)&&!d.jumped){(d.leftDoubleStep||d.rightDoubleStep)&&!T.has(y.Holdswitch)&&(T.add(y.Doublesteps),$(d,E,m,s)||w.add(v.UnmarkedDoublestep));for(const C of g.movedFeet){const b=g.footColumns[C];if(f.combinedColumns[b]!=r.NONE&&!(f.combinedColumns[b]==C||f.combinedColumns[b]==I[C])){s.sideArrows.includes(b)?T.add(y.Sideswitches):T.add(y.Footswitches);break}}}(d.leftBracket||d.rightBracket)&&T.add(y.Brackets),(d.leftJack||d.rightJack)&&!d.previousJumped&&!T.has(y.Brackets)&&(T.add(y.Jacks),(m.mines.some(C=>C!==void 0)||m.fakeMines.some(C=>C!==void 0)&&m.second-o.length<.2)&&w.add(v.MissedFootswitch)),d.rightPos.x<d.leftPos.x&&T.add(y.Crossovers),j(d,m,l,c)&&w.add(v.Ambiguous),d.movedLeft&&Math.abs(d.previousLeftPos.y-d.leftPos.y)>1.3&&h.set(c+1,r.LEFT_HEEL),d.movedRight&&Math.abs(d.previousRightPos.y-d.rightPos.y)>1.3&&h.set(c+1,r.RIGHT_HEEL),T.size==0?o.push(void 0):o.push(T),w.size&&e.set(c+1,w)}return o.values().forEach(c=>{c&&c.forEach(f=>{i[f]=(i[f]||0)+1})}),e.values().forEach(c=>{c.forEach(f=>{a[f]=(a[f]||0)+1})}),{techRows:o,techErrors:e,facingRows:n,candles:h,techCounts:i,techErrorCounts:a}}function $(l,t,s,o){for(let e=0;e<o.layout.length;e++)if(t.holds[e]&&!t.holdTails.has(e)||s.holds[e]!==void 0)return!0;return!!(l.leftDoubleStep&&(s.mines[l.initialState.footColumns[r.LEFT_HEEL]]||s.fakeMines[l.initialState.footColumns[r.LEFT_HEEL]]||s.mines[l.initialState.footColumns[r.LEFT_TOE]]||s.fakeMines[l.initialState.footColumns[r.LEFT_TOE]])||l.rightDoubleStep&&(s.mines[l.initialState.footColumns[r.RIGHT_HEEL]]||s.fakeMines[l.initialState.footColumns[r.RIGHT_HEEL]]||s.mines[l.initialState.footColumns[r.RIGHT_TOE]]||s.fakeMines[l.initialState.footColumns[r.RIGHT_TOE]]))}function j(l,t,s,o){if(!l.previousJumped||t.notes.filter(a=>a!==void 0).length!=1)return!1;const e=t.notes.findIndex(a=>a!==void 0);if(l.initialState.combinedColumns[e]==l.resultState.combinedColumns[e]||l.initialState.combinedColumns[e]==I[l.resultState.combinedColumns[e]])return!1;const i=s[o].children.get(s[o+1].key).TOTAL-s[o].children.get(s[o+1].key).DISTANCE;return!!s[o].children.entries().some(([a,n])=>a==s[o+1].key?!1:n.TOTAL-n.DISTANCE<=i)}const q=5e-4;class F{children=new Map;state;key;constructor(t,s){this.state=t,s?this.key=s:this.key=t.toKey()}}class X{costCalc;layout;initialRow={notes:[],holds:[],holdTails:new Set,mines:[],fakeMines:[],second:-1,beat:-1,columns:[],overrides:[],id:"start"};endRow={notes:[],holds:[],holdTails:new Set,mines:[],fakeMines:[],second:-1,beat:-1,columns:[],overrides:[],id:"end"};initialNode;endNode;cachedEdges=new Map;cachedLowestCost=new Map;edgeCacheSize=0;permuteCache=new Map;nodeMap=new Map;nEdges=0;bestPath;bestPathCost=0;bestPathSet;debugStats={lastUpdatedRowStart:-1,lastUpdatedOldRowEnd:-1,lastUpdatedRowEnd:-1,rowUpdateTime:0,lastUpdatedNodeStart:-1,lastUpdatedNodeEnd:-1,nodeUpdateTime:0,createdNodes:0,createdEdges:0,calculatedEdges:0,cachedEdges:0,edgeUpdateTime:0,cachedBestRows:0,pathUpdateTime:0,rowStatsUpdateTime:0};notedataRows=[];nodeRows=[];constructor(t){if(this.notedataRows=[],this.layout=D[t],!this.layout)throw new Error(`Unsupported game type: ${t}`);this.costCalc=new K(t),this.initialNode=new F(new P(this.initialRow,[],new Array(5).fill(-1))),this.endNode=new F(new P(this.endRow,[],new Array(5).fill(-1)))}compute(t,s,o){if(this.layout==null)return null;const e=this.recalculateRows(t,s,o),i=this.recalculateStates(e),a=this.computeCosts(i);if(this.computeBestPath(a),this.edgeCacheSize>this.nEdges*2){this.edgeCacheSize=0;const d=new Map;for(const T of this.nodeRows)for(const w of T.nodes)for(const[C,b]of w.children.entries()){let p=d.get(w.key);p||(p=new Map,d.set(w.key,p)),p.set(C,b),this.edgeCacheSize++}this.cachedEdges=d}if(this.cachedLowestCost.size>this.nodeMap.size*2&&this.cachedLowestCost.clear(),!this.bestPath)return null;const h=new Map;this.notedataRows.forEach((d,T)=>{this.nodeMap.get(this.bestPath[T+1]).state.combinedColumns.forEach((C,b)=>{C!=r.NONE&&d.notes[b]&&h.set(d.notes[b].beat.toFixed(3)+"-"+b,C)})});const c=this.bestPath.map((d,T)=>T==0?this.initialNode.state:T==this.bestPath.length-1?this.endNode.state:this.nodeMap.get(d).state),f=this.bestPath.map((d,T)=>T==0?this.initialNode:T==this.bestPath.length-1?this.endNode:this.nodeMap.get(d)),E=performance.now(),g=z(f.slice(1,-1),this.notedataRows,this.layout);this.debugStats.rowStatsUpdateTime=performance.now()-E;const m=this.notedataRows.map(d=>({beat:d.beat,second:d.second}));return{parityLabels:h,states:c,rowTimestamps:m,...g}}recalculateRows(t,s,o){const e=performance.now(),i=B(this.notedataRows,Math.round(t*48),Math.round(s*48),u=>Math.round(u.beat*48)),a=i[0];let n=i[1];const[h,c]=B(o,Math.round(t*48),Math.round(s*48),u=>Math.round(u.beat*48)),f=o.slice(h,c);let E=[],g=[],m=[],d=[],T=[],w=h-1;const C=new Array(this.layout.columnCount).fill(0);let b=0;for(;w>=0&&b<C.length;){const u=o[w];if(u.warped){w--;continue}if(C[u.col]==1){w--;continue}if(u.type=="Mine"&&b==0){u.fake?m[u.col]===void 0&&(T[u.col]=u.second):g[u.col]===void 0&&(d[u.col]=u.second),w--;continue}if(u.fake){w--;continue}C[u.col]=1,b++,N(u)&&(E[u.col]=u),w--}let p=null,M=null,O=[],k=[];const H=[];for(const u of f)if(!u.warped){if(u.type=="Mine"){this.isSameSecond(u.second,p)&&H.length>0?u.fake?m[u.col]=u.second:g[u.col]=u.second:u.fake?T[u.col]=u.second:d[u.col]=u.second;continue}u.fake||(this.isSameSecond(p,u.second)||(p!=null&&M!=null&&(H.push({notes:O,holds:E.map(R=>{if(!(R===void 0||this.isSameSecond(R.second,p)||R.second>p))return R}),holdTails:new Set(E.filter(R=>!(R===void 0||Math.abs(R.beat+R.hold-M)>5e-4)).map(R=>R.col)),mines:g,fakeMines:m,second:p,beat:M,columns:[],overrides:k,id:""}),H.at(-1).id=this.rowToKey(H.at(-1))),p=u.second,M=u.beat,O=[],k=[],g=d,m=T,d=[],T=[],E=E.map(R=>{if(!(R===void 0||Math.round(u.beat*48)>Math.round((R.beat+R.hold)*48)))return R})),O[u.col]=u,u.parity?.override&&(k[u.col]=u.parity?.override),N(u)&&(E[u.col]=u))}if(O.length!=0&&(H.push({notes:O,holds:E.map(u=>{if(!(u===void 0||this.isSameSecond(u.second,p)||u.second>p))return u}),holdTails:new Set(E.filter(u=>!(u===void 0||Math.abs(u.beat+u.hold-M)>5e-4)).map(u=>u.col)),mines:g,fakeMines:m,second:p,beat:M,columns:[],overrides:k,id:""}),H.at(-1).id=this.rowToKey(H.at(-1))),this.notedataRows[n]){this.notedataRows[n].mines=d,this.notedataRows[n].fakeMines=T;const u=this.notedataRows[n].id;this.notedataRows[n].id=this.rowToKey(this.notedataRows[n]),u!=this.notedataRows[n].id&&(H.push(this.notedataRows[n]),n++)}return this.debugStats.lastUpdatedRowStart=a,this.debugStats.lastUpdatedOldRowEnd=n,this.debugStats.lastUpdatedRowEnd=a+H.length,this.notedataRows.splice(a,n-a,...H),this.debugStats.rowUpdateTime=performance.now()-e,{startIdx:a,newEndIdx:a+H.length,oldEndIdx:n}}recalculateStates(t){this.debugStats.createdNodes=0,this.debugStats.createdEdges=0;const s=performance.now();this.nodeRows.splice(t.startIdx,t.oldEndIdx-t.startIdx).forEach(i=>{i.nodes.forEach(a=>{this.nodeMap.delete(a.key),this.nEdges-=a.children.size})});let e=t.startIdx??0;for(e-=1,this.debugStats.lastUpdatedNodeStart=e;e<this.notedataRows.length-1;){let i=this.nodeRows[e]?.nodes??[this.initialNode];const a=new Set;for(const h of i){this.nEdges-=h.children.size,h.children.clear();let c=this.getPossibleActions(this.notedataRows[e+1]);this.notedataRows[e+1].overrides.some(f=>f)&&(c=this.filterActions(this.notedataRows[e+1],c,this.notedataRows[e+1].overrides));for(const f of c){const E=this.initResultState(h.state,this.notedataRows[e+1],f),g=E.toKey();let m=this.nodeMap.get(g);m||(m=new F(E,g),this.nodeMap.set(g,m)),a.add(m),this.debugStats.createdEdges+=1,this.nEdges++,h.children.set(m.key,{})}}const n=Array.from(a);if(this.debugStats.createdNodes+=n.length,e+1>=t.newEndIdx){const h=this.nodeRows[e+1];if(h&&h.nodes.length==a.size){h.nodes.sort(),n.sort();let c=!0;for(let f=0;f<h.nodes.length;f++)if(h.nodes[f].key!=n[f].key){c=!1;break}if(c)break}this.nodeRows[e+1]={beat:this.notedataRows[e+1].beat,nodes:n}}else this.nodeRows.splice(e+1,0,{beat:this.notedataRows[e+1].beat,nodes:n});i=n,e++}return this.debugStats.lastUpdatedNodeEnd=e+1,this.debugStats.nodeUpdateTime=performance.now()-s,{firstUpdatedRow:this.debugStats.lastUpdatedNodeStart,lastUpdatedRow:this.debugStats.lastUpdatedNodeEnd}}computeCosts(t){this.debugStats.calculatedEdges=0,this.debugStats.cachedEdges=0;const s=performance.now();let o=t.firstUpdatedRow-1;for(o<-1&&(o=-1);o<this.notedataRows.length-1&&o<t.lastUpdatedRow;){const e=this.nodeRows[o]?.nodes??[this.initialNode];for(const i of e)for(const a of i.children.keys()){const n=this.nodeMap.get(a);if(!n){console.warn("Child node not found for key:",a);continue}const h=n.state,c=i.state;if(this.debugStats.calculatedEdges++,this.cachedEdges.has(i.key)&&this.cachedEdges.get(i.key).has(a)){this.debugStats.cachedEdges++,i.children.set(a,this.cachedEdges.get(i.key).get(a));continue}this.edgeCacheSize++;const f=this.costCalc.getActionCost(c,h,this.notedataRows,o+1);let E=this.cachedEdges.get(i.key);E||(E=new Map,this.cachedEdges.set(i.key,E)),E.set(a,f),i.children.set(a,f)}o++}return this.debugStats.edgeUpdateTime=performance.now()-s,{firstUpdatedCost:Math.max(-1,t.firstUpdatedRow-1),lastUpdatedCost:t.lastUpdatedRow}}computeBestPath(t){const s=performance.now();this.cachedLowestCost.set(this.initialNode.key,{cost:0,path:this.initialNode.key});let o=t.firstUpdatedCost;this.cachedLowestCost.size==1&&(o=-1),this.debugStats.cachedBestRows=t.firstUpdatedCost+1;const e=new Map;for(;o<this.notedataRows.length;){let i=null,a=0;e.clear();const n=this.nodeRows[o]?.nodes??[this.initialNode];for(const h of n){const c=this.cachedLowestCost.get(h.key)?.cost;if(c===void 0){console.warn("No cost found for node:",h.key);continue}o==this.notedataRows.length-1&&h.children.set(this.endNode.key,{TOTAL:0});for(const[f,E]of h.children.entries()){const g=e.get(f);(g===void 0||c+E.TOTAL<g)&&(this.cachedLowestCost.set(f,{cost:c+E.TOTAL,path:this.cachedLowestCost.get(h.key).path+"*"+f}),e.set(f,c+E.TOTAL),(i===null||e.get(f)<a)&&(i=f,a=e.get(f)))}o==this.notedataRows.length-1&&h.children.delete(this.endNode.key)}o++}this.bestPath=this.cachedLowestCost.get(this.endNode.key)?.path.split("*")??[],this.bestPathCost=this.cachedLowestCost.get(this.endNode.key)?.cost??0,this.bestPath||console.error("No best path found"),this.bestPathSet=new Set(this.bestPath??[]),this.debugStats.pathUpdateTime=performance.now()-s}calculatePermuteColumnKey(t){let s="";for(let o=0;o<this.layout.columnCount;o++)(t.notes[o]||t.holds[o])&&(s+=o);return s}getPossibleActions(t){const s=this.calculatePermuteColumnKey(t);let o=this.permuteCache.get(s);return o==null&&(o=this.generateActions(t,new Array(this.layout.columnCount).fill(r.NONE),0),this.permuteCache.set(s,o)),this.permuteCache.get(s)}generateActions(t,s,o){if(o>=s.length){let i=-1,a=-1,n=-1,h=-1;for(let c=0;c<s.length;c++)s[c]!=r.NONE&&(s[c]==r.LEFT_HEEL&&(i=c),s[c]==r.LEFT_TOE&&(a=c),s[c]==r.RIGHT_HEEL&&(n=c),s[c]==r.RIGHT_TOE&&(h=c));return i==-1&&a!=-1||n==-1&&h!=-1?[]:i!=-1&&a!=-1&&!this.layout.bracketCheck(i,a)?[]:n!=-1&&h!=-1&&!this.layout.bracketCheck(n,h)?[]:[s]}const e=[];if(t.notes[o]||t.holds[o]){for(const i of L){if(s.includes(i))continue;const a=[...s];a[o]=i,e.push(...this.generateActions(t,a,o+1))}return e}return this.generateActions(t,s,o+1)}filterActions(t,s,o){const e=new Array(L.length+1).fill(0),i={Left:0,Right:0};for(const n of o)typeof n=="number"?e[n]++:typeof n=="string"&&i[n]++;for(let n=1;n<L.length;n++)if(e[n]>1)return console.warn(`Could not generate any valid permutations with parity overrides for row at beat ${t.beat}, clearing overrides, as there must be something invalid about it.`),s;if(i.Left+e[r.LEFT_HEEL]+e[r.LEFT_TOE]>2||i.Right+e[r.RIGHT_HEEL]+e[r.RIGHT_TOE]>2)return console.warn(`Could not generate any valid permutations with parity overrides for row at beat ${t.beat}, clearing overrides, as there must be something invalid about it.`),s;const a=s.filter(n=>{for(let h=0;h<this.layout.columnCount;h++){const c=o[h];if(c!=null){if(c=="Left"){if(n[h]!=r.LEFT_HEEL&&n[h]!=r.LEFT_TOE)return!1}else if(c=="Right"&&n[h]!=r.RIGHT_HEEL&&n[h]!=r.RIGHT_TOE)return!1}}return!0});return a.length==0?(console.warn(`Could not generate any valid permutations with parity overrides for row at beat ${t.beat}, clearing overrides, as there must be something invalid about it.`),s):a}initResultState(t,s,o){const e=new P(s,o,new Array(5).fill(-1));for(let n=0;n<this.layout.columnCount;n++)e.combinedColumns.push(r.NONE),!(o[n]==null||o[n]==r.NONE)&&(e.footColumns[o[n]]=n,e.combinedColumns[n]=o[n],(s.holds[n]==null||t.combinedColumns[n]!=o[n])&&e.movedFeet.add(o[n]),s.holds[n]!=null&&e.holdFeet.add(o[n]));e.footColumns[r.LEFT_HEEL]==-1&&(e.footColumns[r.LEFT_HEEL]=t.footColumns[r.LEFT_HEEL],e.footColumns[r.LEFT_TOE]=t.footColumns[r.LEFT_TOE],e.combinedColumns[e.footColumns[r.LEFT_HEEL]]==r.NONE&&(e.combinedColumns[e.footColumns[r.LEFT_HEEL]]=r.LEFT_HEEL),e.combinedColumns[e.footColumns[r.LEFT_TOE]]==r.NONE&&(e.combinedColumns[e.footColumns[r.LEFT_TOE]]=r.LEFT_TOE)),e.footColumns[r.RIGHT_HEEL]==-1&&(e.footColumns[r.RIGHT_HEEL]=t.footColumns[r.RIGHT_HEEL],e.footColumns[r.RIGHT_TOE]=t.footColumns[r.RIGHT_TOE],e.combinedColumns[e.footColumns[r.RIGHT_HEEL]]==r.NONE&&(e.combinedColumns[e.footColumns[r.RIGHT_HEEL]]=r.RIGHT_HEEL),e.combinedColumns[e.footColumns[r.RIGHT_TOE]]==r.NONE&&(e.combinedColumns[e.footColumns[r.RIGHT_TOE]]=r.RIGHT_TOE));const i=this.layout.averagePoint(e.leftHeel,e.leftToe),a=this.layout.averagePoint(e.rightHeel,e.rightToe);return i.y>a.y?e.frontFoot=r.LEFT_HEEL:a.y>i.y?e.frontFoot=r.RIGHT_HEEL:e.frontFoot=t.frontFoot,e}rowToKey(t){let s="";for(let n=0;n<this.layout.columnCount;n++)t.notes[n]&&(s+=n+"|");const o=t.fakeMines.map((n,h)=>n===void 0?"0":h+"|"+n.toFixed(3)).join("^"),e=t.mines.map((n,h)=>n===void 0?"0":h+"|"+n.toFixed(3)).join("^");let i="";for(let n=0;n<this.layout.columnCount;n++)t.holdTails.has(n)?i+=n+"T":t.holds[n]!==void 0&&(i+=n+"H");i=i.replace(/0+$/,"");let a="";for(let n=0;n<this.layout.columnCount;n++)t.overrides[n]!==void 0&&(a+=n+""+t.overrides[n]);return`${t.beat.toFixed(3)}-${s}-${o}-${e}-${i}-${a}`}isSameSecond(t,s){return t===null||s===null?!1:Math.abs(t-s)<q}deleteCache(){this.cachedEdges.clear(),this.cachedLowestCost.clear(),this.edgeCacheSize=0,this.permuteCache.clear()}reset(){this.bestPath=void 0,this.bestPathCost=0,this.bestPathSet=void 0,this.nodeMap.clear(),this.nEdges=0,this.nodeRows=[],this.notedataRows=[],this.deleteCache()}}let S;function Y(){return S?{edgeCacheSize:S.edgeCacheSize,nodeMap:S.nodeMap,bestPath:S.bestPath,bestPathCost:S.bestPathCost,bestPathSet:S.bestPathSet,notedataRows:S.notedataRows,nodeRows:S.nodeRows,stats:S.debugStats}:null}function Q(){return S?{removedRowsStart:S.debugStats.lastUpdatedRowStart,removedRowsEnd:S.debugStats.lastUpdatedOldRowEnd,newRows:S.notedataRows.slice(S.debugStats.lastUpdatedRowStart,S.debugStats.lastUpdatedRowEnd),newStates:S.nodeRows.slice(Math.max(0,S.debugStats.lastUpdatedNodeStart),S.debugStats.lastUpdatedNodeEnd),bestPath:S.bestPath,bestPathCost:S.bestPathCost,bestPathSet:S.bestPathSet,edgeCacheSize:S.edgeCacheSize,stats:S.debugStats}:null}function B(l,t,s,o){if(l.length==0)return[0,0];let e=x(l,t,o);for(o(l[e])<t&&e++;l[e-1]&&o(l[e-1])==t;)e--;let i=x(l,s,o);for(o(l[i])>s&&i--;l[i+1]&&o(l[i+1])==s;)i++;return[e,i+1]}function x(l,t,s){if(s=s??(i=>i),l.length==0)return-1;if(t>=s(l[l.length-1])){let i=l.length-1;for(;i>0&&s(l[i-1])==t;)i--;return i}let o=0,e=l.length;for(;o<=e&&o<l.length;){let i=o+e>>>1;if(s(l[i])==t){for(;i>0&&s(l[i-1])==t;)i--;return i}s(l[i])<t&&(o=i+1),s(l[i])>t&&(e=i-1)}return Math.max(0,e)}self.onmessage=l=>{switch(l.data.type){case"init":if(S){postMessage({type:"error",id:l.data.id,error:"Instance already initialized"});return}try{S=new X(l.data.gameType),postMessage({type:"init",id:l.data.id})}catch(t){postMessage({type:"error",id:l.data.id,error:t.message})}break;case"compute":{if(!S){postMessage({type:"error",id:l.data.id,error:"Instance not initialized"});return}const t=S.compute(l.data.startBeat,l.data.endBeat,l.data.notedata);if(!t){postMessage({type:"error",id:l.data.id,error:"No path found"});return}postMessage({type:"compute",id:l.data.id,data:t,debug:l.data.debug?Q():void 0});break}case"getDebug":{if(!S){postMessage({type:"error",id:l.data.id,error:"Instance not initialized"});return}postMessage({type:"getDebug",id:l.data.id,data:Y()});break}}}})();
